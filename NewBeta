----- INTRO SCRIPT ----------
if not game:IsLoaded() then
    while not game:IsLoaded() do wait(1) end
end

loadstring(game:HttpGet("https://raw.githubusercontent.com/Roleck11/MainScripts/main/AdoptMeIntroCheck"))()

print(" === Executed Roleck Minigame Script - Earning New Currency ===")

---------- Extra GUI Control and Buttons and IMAGES blah blah -------------
game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Enabled = true
game:GetService("Players").LocalPlayer.PlayerGui.InteractionsApp.Enabled = true
game:GetService("Players").LocalPlayer.PlayerGui.NavigatorApp.Enabled = true

------------ MAIN MINIGAME SCRIPT -------------
local get_thread_identity = get_thread_context or getthreadcontext or getidentity or syn.get_thread_identity
local set_thread_identity = set_thread_context or setthreadcontext or setidentity or syn.set_thread_identity
local Location = nil
local Player = game.Players.LocalPlayer
local Fsys = require(game.ReplicatedStorage:WaitForChild("Fsys")).load

for i, v in pairs(debug.getupvalue(require(game:GetService("ReplicatedStorage").Fsys).load("RouterClient").init, 4)) do
    v.Name = i
end

_G.AlreadyExecuted = false

function PlayMinigame()
    ------ PLAY MINIGAME CODE
    _G.AlreadyExecuted = true
    while GameStatus() do
        for i = 1, 3 do 
            game:GetService("ReplicatedStorage").API["MinigameAPI/MessageServer"]:FireServer("egg_catch_minigame", "candy_collected", i)
        end
        wait()
    end
    _G.AlreadyExecuted = false
end

-------- *** GameStatus
function GameStatus()
    return workspace.StaticMap.egg_catch_minigame_minigame_state.is_game_active.Value
end

for i, v in pairs(getgc()) do
    if type(v) == "function" then
        if getfenv(v).script == game.ReplicatedStorage.ClientModules.Core.InteriorsM.InteriorsM then
            if table.find(getconstants(v), "LocationAPI/SetLocation") then
                Location = v
                break
            end
        end
    end
end
local SetLocation = function(A, B, C)
    local O = get_thread_identity()
    set_thread_identity(2)
    Location(A, B, C)
    set_thread_identity(O)
end

-------- *** GoToMinigame | PlaceName
local GoToMinigameLunar = function()
    game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
    SetLocation("Easter2024Shop", "MainDoor", {})
    wait(2)
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(workspace.Interiors.Easter2024Shop.Minigame.JoinZone.WorldPivot.Position)
    game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
end

-------- *** Get Lobby, check Interiors
function GetLobby()
    for i, v in pairs(workspace.Interiors:GetChildren()) do
        if tostring(v) == "Easter2024Shop" then
            return true
        else
            print(v)
            return false
        end
    end
end

_G.LLLaffan = true
while _G.LLLaffan == true do
    if GetLobby() == true then
        print("Inside Lobby")
        if (workspace.Interiors.Easter2024Shop.Minigame.JoinZone.WorldPivot.Position and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - workspace.Interiors.Easter2024Shop.Minigame.JoinZone.WorldPivot.Position).magnitude < 23) then
            print("Inside Join Zone")
        elseif GameStatus() == true then
            print("Inside Minigame")
            if _G.AlreadyExecuted == false then
                PlayMinigame()
            end
        else
            if GetLobby() == true then
                print("In Lobby, But Not in Join Zone / Minigame")
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(workspace.Interiors.Easter2024Shop.Minigame.JoinZone.WorldPivot.Position)
            else
                GoToMinigameLunar()
            end
        end
    else
        GoToMinigameLunar()
    end
    wait(5)
end


---- Auto Claim Quests
--for i, v in pairs(Fsys("ClientData").get("quest_manager")["quests_cached"]) do
--    if v["steps_completed"] >= 1 then
--        Fsys("RouterClient").get("QuestAPI/ClaimQuest"):InvokeServer(v["unique_id"])
--        task.wait()
--    end
--end
